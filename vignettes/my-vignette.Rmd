---
title: "scmeth Vignette"
author: "Divy S. Kangeyan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Vignette Title}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
Contents
-----------
1. Introduction 

2. Installation

3. Input files

4. Usage

    4.1 Report 
    
    4.2 Functions
    
---------------------

    
1. Introduction
---------------------
<p style="text-align: justify;">
Though a small chemical change in the genome, DNA methylation has significant
impact in several diseases, developmental processes and other biological 
changes. Hence methylation data should be analyzed carefully to gain 
biological insights. **scmeth** package offers some tools to conduct 
methylation analysis properly. 
</p>

<p style="text-align: justify;">
This bioconductor package contains functions to perform quality control and 
preprocessing analysis for methylation data. This package is especially 
customized to use the output from the firecloud implementation of methylation 
pipeline. However it still has functions to generate bsseq objects with
methylation information given the bedgraph file obtained from *methyldackel*. 
For now only human and mouse genomes are supported in this package but in the 
future we will expand to other organisms. In addition to individual functions, 
**report** function in the **scmeth** provides all inclusive report using most 
of the functions in this package. If users prefer they can just use the 
**report** function to gain summary of their data.
</p>

2. Installation
---------------------
**scmeth** is available in bioconductor and can be downloads using the 
following commands
```{r, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("scmeth")
```

3. Input files
---------------------
<p style="text-align: justify;">
Main input files that is used in most of the functions is an .rda file 
containing *bsseq* object. This can be obtained from the firecloud 
implementation of the methylation pipeline. However if the user has an output
from *Methyldackel* as a bedgraph file then they can use the **createRDA** and
**combineRDA** function to create the bsseq object. When the user has this 
bsseq object it should first be loaded with the following command
</p>

```{r, eval=FALSE}
load('methylationData.rda')
```

<p style="text-align: justify;">
These bsseq objects are saved as *bs*, so the user can use the loaded bsseq
object in the functions of the package. 
</p>


4. Usage
---------------------

4.1 Report
--------------

<p style="text-align: justify;">
A comprehensive quality control report can be generated in the package via 
**report** function in this package. report function takes the bs object, 
the directory where the report should be saved, organism that this data is 
obtained from and the genomic build. Following is an example usage of the 
**report** function.

</p>

```{r, eval=FALSE}
library(scmeth)
scmeth::report(bs, '~/Documents',Mmusculus,"mm10")
```


<p style="text-align: justify;">
Following the command an html report will be stored in the indicated directory. 
</p>

--------------------------------------------------------------------------------

4.2 Functions
-----------------
<p style="text-align: justify;">
This section will elaborate on some of the main functions and show the usage 
of these functions based on a sample data set that comes along with the 
package. 

**scmeth** package contains several functions to assess different metrics and 
success of the sequencing process. 

### coverage
One main metric is the CpG coverage. Coverage of the CpG can be assessed in 
different ways. Very basic one is to check how many CpG were observed in each 
sample. **coverage** function can be used to get this information. 

</p>
Loading the data
```{r}
library(scmeth)
load(system.file("extdata",'bsObject.rda',package='scmeth'))
```

```{r}
scmeth::coverage(bs)
```


### repmask
<p style="text-align: justify;">
CpG Islands are characterized by their high GC content, high level of observed 
to expected ratio of CpGs and length over 500 bp. However some repeat regions 
in the genome also fit the same criteria although they are not bona fide CpG 
Island. Therefore it is important to see how many CpGs are observed in the non 
repeat regions of the genome. **repMask** functions provide information on the 
CpG coverage in non repeat regions of the genome. In order to build the repeat 
mask regions of the genome **repmask** function will require the organism and 
the genome build information.
</p>

```{r, warning=FALSE,message=FALSE}
library(BSgenome.Mmusculus.UCSC.mm10)
scmeth::repMask(bs,Mmusculus,"mm10")
```

<p style="text-align: justify;">
There are several other ways the number of CpGs captured can be observed. 
One of the way is to observe how the CpGs are distributed across different 
chromosomes. (Since the example data only contains infroamtion in chromosome 1
only the CpGs covered in chromosome 1 is shown.)

</p>

```{r, warning=FALSE}
scmeth::chromosomeCoverage(bs)
```

### featureCoverage
<p style="text-align: justify;">
Another way to observe the distribution of CpGs is to classify them by the 
genomic features they belong. Some of the features are very specific to the CpG
dense regions such as CpG Islands, CpG Shores, CpG Shelves etc. Others are 
general genomic features such as introns, exons, promoters etc. This 
information can be obtained by **featureCoverage** function. In addition to the
bs object this function requires the genomic features of interest and the 
genome build.
</p>
```{r, warning=FALSE,message=FALSE}
library(annotatr)
DT::datatable(scmeth::featureCoverage(bs,features=c('genes_exons','genes_introns',
                            'cpg_islands'),"mm10"))


```
</p>



### cpgDensity
<p style="text-align: justify;">
CpGs are not distributed across the genome uniformly. Most of the genome 
contains very low percentage of CpGs except for the CpG dense regions,
i.e. CpG islands. Bisulfite sequencing targets all the CpGs across the genome,
however reduced representation bisulfite sequencing (RRBS) target CpG dense CpG
islands. Therefore CpG density plot will be a great diagnostic to see whether 
the protocol succeeded. In order to calculate the CpG density a window length 
should be specified. By default **cpgDensity** function chooses 1kB regions. 

Therefore CpG density plot can be used to check if the whether the protocol
specifically targeted CpG dense or CpG sparse regions or whether CpGs were 
obtained uniformly across the regions.
</p>

```{r,warning=FALSE,message=FALSE}
library(BSgenome.Mmusculus.UCSC.mm10)
DT::datatable(scmeth::cpgDensity(bs,Mmusculus,windowLength=1000))
```

### downsample
<p style="text-align: justify;">
In addition to the CpG coverage the methylation data can be assessed via down
sampling analysis, methylation bias plot and methylation distribution. Down 
sampling analysis is a tool to assess whether the sequencing process achieved 
the saturation level in terms of CpG capture. In order to perform down sampling
analysis the CpGs that are covered at least once sampled via binomial random 
sampling with given probability. At each probability level the number of CpGs
captured is assessed. If the number of CpG captured attains a plateau then the
sequencing was successful. **downsample** function provides a matrix of CpG 
coverage for each sample at various down sampling rates. The report renders 
this information into a plot. Downsampling rate ranges from 0.01 to 0.99, 
however users can change the donwsampling rates.
</p>

```{r,warning=FALSE}
DT::datatable(scmeth::downsample(bs))
```


### mbiasPlot
<p style="text-align: justify;">
Methylation bias plot shows the methylation along the reads. In a high quality 
samples methylation across the read would be more or less a horizontal line. 
However there could be fluctuations in the beginning or the end of the read due
to the quality of the bases. Single cell sequencing samples also can show 
jagged trend in the methylation bias plot due to lower read count. Methylation
bias can be assessed via **mbiasPlot** function. This function takes the mbias
file generated from *methyldackel* and generates the methylation bias plot.
</p>

```{r,warning=FALSE,message=FALSE,fig.width=6,fig.height=6}
methylationBiasFile<-'2017-04-21_HG23KBCXY_2_AGGCAGAA_TATCTC_pe.M-bias.txt'
scmeth::mbiasplot(mbiasFiles=system.file("extdata",methylationBiasFile,package='scmeth'))
```
</p>

### methylationDist
<p style="text-align: justify;">
**methylationDist** function provides the methylation distribution of the 
samples. By default it will produce distribution for all the sample but users
can change it by specifying all=FALSE.
</p>
```{r,warning=FALSE,message=FALSE,fig.width=6}
scmeth::methylationDist(bs)
```


### bsConversionPlot
<p style="text-align: justify;">
Another important metric in methylation analysis is the bisulfite conversion 
rate. Bisulfite conversion rate indicates out of all the Cytosines in the non
CpG context what fraction of them were methylated. Ideally this number should
be 1 or 100% indicating none of the non CpG context cytosines are methylated. 
However in real data this won't be the case, yet a bisulfite conversion
rate below 95% indicates some problem with sample preparation. 
**bsConversionPlot** function generates a plot showing this metric for each 
sample.
</p>
```{r}
#scmeth::bsConversionPlot(bs)
```



<p style="text-align: justify;">
If the users don't have a bsseq object with all the information then 
**createRDA** and **combineRDA**  functions can be used to generate the bsseq
object from bedGraph files containing methylation information for each CpG 
site. These bedGraph files can be obtained from *methylDackel* or some other 
software. 
</p>

### createRDA
**createRDA** function generate an RDA object for each sample separately
```{r,warning=FALSE}
CpGBedGraphFile_1<-system.file("extdata",
                                'sc-RRBS_zyg_01_chr1_CpG.bedGraph',package='scmeth')
readMetricsFile_1<-system.file("extdata",
                                'sc-RRBS-zygote_01.read_metrics.txt',package='scmeth')
bsConversionFile_1<-system.file("extdata",
                                'sc-RRBS-zygote_01.bsConv.txt',package='scmeth')
CpGBedGraphFile_2<-system.file("extdata",
                                'sc-RRBS_zyg_02_chr1_CpG.bedGraph',package='scmeth')
readMetricsFile_2<-system.file("extdata",
                                'sc-RRBS-zygote_02.read_metrics.txt',package='scmeth')
bsConversionFile_2<-system.file("extdata",
                                'sc-RRBS-zygote_02.bsConv.txt',package='scmeth')
CpGBedGraphFile_3<-system.file("extdata",
                                'sc-RRBS_zyg_03_chr1_CpG.bedGraph',package='scmeth')
readMetricsFile_3<-system.file("extdata",
                                'sc-RRBS-zygote_03.read_metrics.txt',package='scmeth')
bsConversionFile_3<-system.file("extdata",
                                'sc-RRBS-zygote_03.bsConv.txt',package='scmeth')


rda1<-createRDA(CpGBedGraphFile_1,readMetricsFile_1,bsConversionFile_1)
rda2<-createRDA(CpGBedGraphFile_2,readMetricsFile_2,bsConversionFile_2)
rda3<-createRDA(CpGBedGraphFile_3,readMetricsFile_3,bsConversionFile_3)
```

### combineRDA
**combineRDA** pools the information from multiple samples for comparison.
```{r}
combineRDA(c(rda1,rda2,rda3))
```

--------------------------

